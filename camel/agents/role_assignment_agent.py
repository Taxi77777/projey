# =========== Copyright 2023 @ CAMEL-AI.org. All Rights Reserved. ===========
# Licensed under the Apache License, Version 2.0 (the “License”);
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an “AS IS” BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# =========== Copyright 2023 @ CAMEL-AI.org. All Rights Reserved. ===========
import re
from typing import Any, Optional, Tuple, Union

from camel.agents import ChatAgent
from camel.messages import SystemMessage, UserChatMessage
from camel.prompts import TextPrompt
from camel.typing import ModelType, RoleType


class RoleAssignmentAgent(ChatAgent):
    r"""
    An agent that generates role names based on the task prompt.
    Attributes:
        role_assignment_prompt (TextPrompt): A prompt for the agent to generate
        role names.
    args:
        model (ModelType): The tupe of model to use for the agent.
            (default: :obj: 'ModelType.GPT_3_5_TURBO')
        model_config (Any): The configuration for the model.
            (default: :obj: 'None')
    """

    def __init__(
        self,
        model: ModelType = ModelType.GPT_3_5_TURBO,
        model_config: Any = None,
    ) -> None:
        self.role_assignment_prompt = TextPrompt(
            "Given this task, \"{task}\", generate {n} role names along with" +
            "their description" +
            "if {n} is 2, one for the AI User, another for AI Assistant.")

        system_message = SystemMessage(
            role_name="Role Assigner",
            role_type=RoleType.ASSISTANT,
            content="You assign roles and descriptions based on tasks.",
        )

        super().__init__(system_message, model, model_config)

    def step(self, task_prompt: Union[str, TextPrompt],
             num_roles: int) -> Tuple[TextPrompt, TextPrompt]:
        r""""
        Generate role names based on the input task prompt.
        Args:
            task_prompt (Union[str, TextPrompt]): The prompt
            for the task based on which
            the roles are to be generated
            num_roles (int): The number of role names and
            descriptions to generate
            Returns:
                dict: The role names and descriptions generated by the agent.
        """

        self.reset()

        task_msg = UserChatMessage(
            role_name="Role Assigner",
            content=self.role_assignment_prompt.format(task=task_prompt,
                                                       n=num_roles))

        response = super().step(task_msg)
        role_msgs = response.msgs
        terminated = response.terminated

        role_details = {}

        for message in role_msgs:
            content = message.content
            lines = content.split("\n\n")
            print(content)

            if len(lines) == 2:
                for line in lines:
                    line_split = line.split("\n")
                    if 'AI User' in line_split[0]:
                        role_name = line_split[0].split(":")[1].strip()
                        role_desc = line_split[1].split(":")[1].strip()
                        role_details['ai_user'] = {
                            "name": role_name,
                            "description": role_desc
                        }

                    elif 'AI Assistant' in line_split[0]:
                        role_name = line_split[0].split(":")[1].strip()
                        role_desc = line_split[1].split(":")[1].strip()
                        role_details['ai_assistant'] = {
                            "name": role_name,
                            "description": role_desc
                        }

            else:
                for i, line in enumerate(lines):
                    line_split = line.split("\n")
                    role_name = line_split[0].split(":")[1].strip()
                    role_desc = line_split[1].split(":")[1].strip()
                    role_details[f"role_name_{i+1}"] = {
                        "name": role_name,
                        "description": role_desc
                    }
        print(role_details)

        if len(role_details) != num_roles:
            raise RuntimeError("Got None or insufficient Role messages. ")
        if terminated:
            raise RuntimeError("Role assignment failed.")

        return role_details

    def step_completion(
        self,
        num_roles: Optional[int] = 2,
        task_prompt: Union[str, TextPrompt] = None,
    ) -> Tuple[TextPrompt, TextPrompt]:
        r""" "
         Generate role names based on the input task prompt.

         Args:
             num_roles (int): The number of roles to generate.
                 (default: :obj:`2`)
             task_prompt (Union[str, TextPrompt]): The prompt
                 for the task based on which the roles are to be generated.

         Returns:
             Tuple[TextPrompt, Textprompt]: The role names generated by the
                 agent for the AI user and AI assistant, respectively.
         """
        expert_prompts = "\n".join(
            f"Domain expert {i + 1}: <|blank|>\n"
            f"Associated competencies, professional characteristics, duties "
            f"and workflows: <|blank|>. End.\n" for i in range(num_roles))
        role_assignment_generation_prompt = TextPrompt(
            "You are the boss, you need to recruit experts in {num_roles} " +
            "different fields to solve the task.\n" +
            "Please tell me which domain experts should be recruited, " +
            "and what competencies, professional characteristics, duties " +
            "and workflows to complete the task.\n" +
            "ONLY return the content in BLANK.\n\n" + "===== TASK =====\n" +
            "{task}\n\n" + "===== PROMPT =====\n" + expert_prompts)
        role_assignment_generation = role_assignment_generation_prompt.format(
            num_roles=num_roles, task=task_prompt)

        role_assignment_generation_msg = UserChatMessage(
            role_name="Role Assigner", content=role_assignment_generation)

        output_completions, terminated, info = super().step_completion(
            input_prompt_for_completion=role_assignment_generation_msg,
            max_tokens=100 * num_roles,  # 100 maximum tokens per role
        )

        # Distribute the output completions into role names and descriptions
        role_names = re.findall(
            r"Domain expert \d: (.+?)\nAssociated competencies,",
            output_completions[0]["text"],
            re.DOTALL,
        )
        role_descriptions = re.findall(
            r"Associated competencies, professional characteristics, duties"
            " and workflows: (.+?) End.",
            output_completions[0]["text"],
            re.DOTALL,
        )
        role_description_dict = {
            role_name: description
            for role_name, description in zip(role_names, role_descriptions)
        }

        if len(role_names) != num_roles or len(role_descriptions) != num_roles:
            raise RuntimeError("Got None or insufficient Role messages. ")
        if terminated:
            raise RuntimeError("Role assignment failed.")

        return role_names, role_description_dict, terminated, info
