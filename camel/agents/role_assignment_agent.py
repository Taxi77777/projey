from typing import Any, Tuple, Union

from camel.agents import ChatAgent
from camel.messages import SystemMessage, UserChatMessage
from camel.prompts import TextPrompt
from camel.typing import ModelType, RoleType


class RoleAssignmentAgent(ChatAgent):
    r"""
    An agent that generates role names based on the task prompt.
    Attributes:
        role_assignment_prompt (TextPrompt): A prompt for the agent to generate
        role names.
    args:
        model (ModelType): The tupe of model to use for the agent.
            (default: :obj: 'ModelType.GPT_3_5_TURBO')
        model_config (Any): The configuration for the model.
            (default: :obj: 'None')
    """

    def __init__(
        self,
        model: ModelType = ModelType.GPT_3_5_TURBO,
        model_config: Any = None,
    ) -> None:
        self.role_assignment_prompt = TextPrompt(
            "Given this task, \"{task}\", generate {n} role names along with" +
            "their description" +
            "if {n} is 2, one for the AI User, another for AI Assistant")

        system_message = SystemMessage(
            role_name="Role Assigner",
            role_type=RoleType.ASSISTANT,
            content="You assign roles and descriptions based on tasks.",
        )

        super().__init__(system_message, model, model_config)

    def step(self, task_prompt: Union[str, TextPrompt],
             num_roles: int) -> Tuple[TextPrompt, TextPrompt]:
        r""""
        Generate role names based on the input task prompt.
        Args:
            task_prompt (Union[str, TextPrompt]): The prompt
            for the task based on which
            the roles are to be generated
            num_roles (int): The number of role names and
            descriptions to generate
            Returns:
                dict: The role names and descriptions generated by the agent.
        """

        self.reset()

        task_msg = UserChatMessage(
            role_name="Role Assigner",
            content=self.role_assignment_prompt.format(task=task_prompt,
                                                       n=num_roles))

        role_msgs, terminated, _ = super().step(task_msg)

        role_details = {}

        for message in role_msgs:
            content = message.content
            lines = content.split("\n\n")

            if len(lines) == 2:
                for line in lines:
                    if 'AI User' in line:
                        line_split = line.split("\n")
                        role_name = line_split[0].split(":")[1].strip()
                        role_desc = line_split[1].split(":")[1].strip()
                        role_details['ai_user'] = {
                            "name": role_name,
                            "description": role_desc
                        }

                    elif 'AI Assistant' in line:
                        line_split = line.split("\n")
                        role_name = line_split[0].split(":")[1].strip()
                        role_desc = line_split[1].split(":")[1].strip()
                        role_details['ai_assistant'] = {
                            "name": role_name,
                            "description": role_desc
                        }

            else:
                for i, line in enumerate(lines):
                    line_split = line.split("\n")
                    role_name = line_split[0].split(":")[1].strip()
                    role_desc = line_split[1].split(":")[1].strip()
                    role_details[f"role_name_{i+1}"] = {
                        "name": role_name,
                        "description": role_desc
                    }

        if len(role_details) != num_roles:
            raise RuntimeError("Got None or insufficient Role messages. ")
        if terminated:
            raise RuntimeError("Role assignment failed.")

        return role_details
